bool Human::checkBoundry(unsigned int a,int check) {
	a *= 10;
	switch (check)
	{
	case 1: //can i go to the left?
		if (Position.x > 0 + a +1)
		{
			return true;
			break;
		}
	case 2:  //can i go to the right?
		if (Position.x < boundry.x - a-1)
		{
			return true;
			break;
		}
	case 3: //can I go to up?
		if (Position.y > 0 + a+1)
		{
			return true;
			break;
		}
	case 4://can i go down?
		if (Position.y < boundry.y - a-1)
		{
			return true;
			break;
		}
	default:
		return false;
		break;
	}
	return false;
}

void Human::walk(const std::vector<std::vector<int>>& Intmap) {
	Target(Intmap);
	xMap = Position.x / 10;
	yMap = Position.y / 10;
	std::cout << "\nXmap" << xMap << " ,Ymap " << yMap ;

	if (TargetPosition.x < Position.x && checkBoundry(4, 1) && ((Intmap[xMap - 3][yMap] == 2) || Intmap[xMap - 2][yMap] == 2 || Intmap[xMap - 1][yMap] == 2))
	{
		Position.x -= xVelocity;
	}
	else if (TargetPosition.x > Position.x && checkBoundry(4, 2) && ((Intmap[xMap+3][yMap ] == 2) || Intmap[xMap+2][yMap] == 2 || Intmap[xMap+1][yMap] == 2) ){
		Position.x += xVelocity;
	}
	else if (TargetPosition.y < Position.y && checkBoundry(4, 3) &&( (Intmap[xMap][yMap - 3] == 2) || Intmap[xMap][yMap - 2] == 2 || Intmap[xMap][yMap - 1] == 2))
	{
		Position.y -= yVelocity;
	}
	else if (TargetPosition.y > Position.y && checkBoundry(4, 4) && ((Intmap[xMap][yMap + 3] == 2)|| Intmap[xMap][yMap + 2] == 2 || Intmap[xMap][yMap + 1] == 2 )){
		Position.y += yVelocity;
	}
	else if (checkBoundry(7, 1) && checkBoundry(7, 2))
	{
		 if (Intmap[xMap - 1][yMap] != 3 && Intmap[xMap + 1][yMap] != 3)
		{
			for (int i = 1;i < 7;i++) {
				if (Intmap[xMap - i][yMap] == 3) {
					Position.x -= xVelocity;
					break;
				}
				else if (Intmap[xMap + i][yMap] == 3) {
					Position.x += xVelocity;
					break;
				}
			}
		}
	}
	else if(checkBoundry(7, 3) && checkBoundry(7, 4))
	{
		if (Intmap[xMap ][yMap-1] != 3 && Intmap[xMap ][yMap+1] != 3)
		{
			for (int i = 1;i < 7;i++) {
				if (Intmap[xMap][yMap-i] == 3) {
					Position.y -= yVelocity;
					break;
				}
				else if (Intmap[xMap][yMap+i] == 3) {
					Position.y += yVelocity;
					break;
				}
			}
		}
	}
	else if (!checkBoundry(13, 1))
	{
		Position.x += xVelocity;
	}
	else if (!checkBoundry(13, 2)) {
		Position.x -= xVelocity;
	}
	else if (!checkBoundry(13, 3))
	{
		Position.y += yVelocity;
	}
	else if (!checkBoundry(13, 4)) {
		Position.y -= yVelocity;
	}
	else { BasicWalk(); }

	Target(Intmap);
	/*Position.x += xVelocity;
	Position.y += yVelocity;*/
	//shape.move(Move);

	//checkBoundry();
	shape.setPosition(Position);

	std::cout <<"\nX" << Position.x << " ,Y " << Position.y<<"\n";

	
}




##version 2

/*if (TargetPosition.x < Position.x && checkBoundry(4, 1) && ((Intmap[xMap - 3][yMap] == 3) || Intmap[xMap][yMap] == 3 ))
	{
		Position.x -= xVelocity;
	}
	else if (TargetPosition.x > Position.x && checkBoundry(4, 2) && ((Intmap[xMap+3][yMap ] == 3) || Intmap[xMap][yMap] == 3))
	{
		Position.x += xVelocity;

	}
	else if (TargetPosition.y < Position.y && checkBoundry(4, 3) &&( (Intmap[xMap][yMap - 3] == 3) || Intmap[xMap][yMap] == 3))
	{
		Position.y -= yVelocity;
	}
	else if (TargetPosition.y > Position.y && checkBoundry(4, 4) && ((Intmap[xMap][yMap + 3] == 3)|| Intmap[xMap][yMap] == 3))
	{
		Position.y += yVelocity;
	}
	else if (checkBoundry(7, 1) && checkBoundry(7, 2))
	{
		 if (Intmap[xMap][yMap-1] == 3 || Intmap[xMap ][yMap+1] == 3)
		{
			for (int i = 1;i < 7;i++) {
				if (Intmap[xMap - i][yMap] == 3) {
					Position.x -= xVelocity;
					break;
				}
				else if (Intmap[xMap + i][yMap] == 3) {
					Position.x += xVelocity;
					break;
				}
			}
		}
	}
	else if(checkBoundry(7, 3) && checkBoundry(7, 4))
	{
		if (Intmap[xMap-1 ][yMap] == 3 || Intmap[xMap+1 ][yMap] == 3)
		{
			for (int i = 1;i < 7;i++) {
				if (Intmap[xMap][yMap-i] == 3) {
					Position.y -= yVelocity;
					break;
				}
				else if (Intmap[xMap][yMap+i] == 3) {
					Position.y += yVelocity;
					break;
				}
			}
		}
	}
	else if (!checkBoundry(13, 1))
	{
		Position.x += xVelocity;
	}
	else if (!checkBoundry(13, 2)) {
		Position.x -= xVelocity;
	}
	else if (!checkBoundry(13, 3))
	{
		Position.y += yVelocity;
	}
	else if (!checkBoundry(13, 4)) {
		Position.y -= yVelocity;
	}*/
	//else { BasicWalk(); }








		/*
			//basic check
			if (X2 > 0 && X2 + xSize < xBoundry && Y2 > 0 && Y2 + ySize < yBoundry && // just chechikng for boundry if % doesn't work
				Intmap[X2][Y2] < PavementTile && Intmap[X2 + xSize-1][Y2] < PavementTile && // max left building check
				Intmap[X2][Y2 + ySize-1] < PavementTile && Intmap[X2 + xSize-1][Y2 + ySize-1] < PavementTile && (//max right building check
					//"expert" checks
					((xSize >3)? (Intmap[X2+3][Y2] < PavementTile && Intmap[X2 + 3][Y2+ ySize - 1] < PavementTile) : true) &&// middle top and middle bottom check
					((ySize > 3) ? (Intmap[X2 ][Y2+3] < PavementTile && Intmap[X2 + xSize - 1][Y2 + 3] < PavementTile) : true) && //middle left and middle right check  //  now everybode hates me for this as they should but it works lol
					//final check for walkable surface
					Intmap[X2 - 1][Y2 - 1] == PavementTile || Intmap[X2 +xSize][Y2 + ySize] == PavementTile)) { // looking in corners for PavementTile
*/

if (!(X2 > 0 && X2 + xSize < xBoundry && Y2 > 0 && Y2 + ySize < yBoundry)) {
				continue;
			}
			if (!(Intmap[X2 - 1][Y2 - 1] == 2 || Intmap[X2 + xSize][Y2 + ySize] == 2)) {
				continue;
			}
			build = true;
			for (int j = 0; j < ySize; ++j) {
				
				for (int i = 0; i < xSize; ++i) {
					std::cout << "\nx:" << X2+i << "	,y:" << Y2+j;
					if (Intmap[X2 + i][Y2 + j] <  2) {
						build = false;
						break;
					}
					if (!build) 
					{ break; }
				}
				
			}

			if (build)
			{
				for (int i = 0; i < ySize; ++i) {
					for (int j = 0; j < xSize; ++j) {
						Intmap[X2 + i][Y2 + j] = getTile();
					}
				}
				std::cout << "\nx:" << xSize << "	,y:" << ySize;
				setPosition(sf::Vector2f(Y2 * 10, X2 * 10));
				return true;
			}
			else
			{
				continue;
			}


			if ( // just chechikng for boundry if % doesn't work
				Intmap[X2][Y2] < PavementTile && Intmap[X2 + xSize-1][Y2] < PavementTile && // max left building check
				Intmap[X2][Y2 + ySize-1] < PavementTile && Intmap[X2 + xSize-1][Y2 + ySize-1] < PavementTile && (//max right building check
					//"expert" checks
					 Intmap[X2+xMidSize][Y2] < PavementTile && Intmap[X2 + xMidSize][Y2+ ySize - 1] < PavementTile  &&// middle top and middle bottom check
					 Intmap[X2 ][Y2+yMidSize] < PavementTile && Intmap[X2 + xSize - 1][Y2 + yMidSize] < PavementTile  && //middle left and middle right check  //  now everybode hates me for this as they should but it works lol
					//final check for walkable surface
					Intmap[X2 - 1][Y2 - 1] == PavementTile || Intmap[X2 +xSize][Y2 + ySize] == PavementTile)) { // looking in corners for PavementTile

				std::cout <<"\n first check;" << Intmap[X2][Y2] << ", " << Intmap[X2 + xSize - 1][Y2] << ", " <<  // max left building check
					"\n second check;" << Intmap[X2][Y2 + ySize - 1] << ", " << Intmap[X2 + xSize - 1][Y2 + ySize - 1] << ", " << //max right building check
					//"expert" checks
					"\n xMidSize check;" << Intmap[X2 + xMidSize][Y2] << ", " << Intmap[X2 + xMidSize][Y2 + ySize - 1] << ", " << // middle top and middle bottom check
					"\n 4 check;" << Intmap[X2][Y2 + yMidSize] << ", " << Intmap[X2 + xSize - 1][Y2 + 3] << ", " <<//middle left and middle right check  //  now everybode hates me for this as they should but it works lol
					//final check for walkable surface
					"\n pevment check;" << Intmap[X2 - 1][Y2 - 1] << ", " << Intmap[X2 + xSize][Y2 + ySize];

				for (int i = 0; i < xSize; ++i) {
					for (int j = 0; j < ySize; ++j) {
						Intmap[X2 + j ][Y2 + i ]  = getTile();
					}
				}				
				std::cout << "\nXmap" << xMap << " ,Ymap " << yMap
						  << "\nX2:" << X2 << " ,Y2:" << Y2;



				// i know i'ts confusing but just resources/Vector_shenanigens.png open for explenation
				setPosition( sf::Vector2f(Y2 * 10, X2 * 10)); 
				return true;